# Implementation Plan: PH-11 -- `NonZeroU32` Tight Type

**Status:** PLAN_APPROVED
**Ticket:** PH-11 "Phase 11: `NonZeroU32` tight type"
**PRD:** `docs/prd/PH-11.prd.md`
**Research:** `docs/research/PH-11.md`
**Phase spec:** `docs/phase/phase-11.md`

---

## Components

### 1. `stdp::U32` parser -- Change `type Dest` from `u32` to `NonZeroU32`

**File:** `src/parse.rs`, lines 14-45 (inside `mod stdp`)

The `stdp::U32` parser currently parses unsigned integers into `u32` and uses a runtime `if value == 0 { return Err(()); }` check to reject zero values. The hint comment at lines 37-39 explicitly recommends replacing this with `NonZeroU32`.

**Current (lines 22, 36-43):**
```rust
type Dest = u32;
// ...
let value = u32::from_str_radix(&remaining[..end_idx], if is_hex { 16 } else { 10 })
    .map_err(|_| ())?;
// подсказка: вместо if можно использовать tight-тип std::num::NonZeroU32
//            (ограничиться NonZeroU32::new(value).ok_or(()).get() - норм)
//            или даже заиспользовать tightness
if value == 0 {
    return Err(()); // в наших логах нет нулей, ноль в операции - фикция
}
Ok((&remaining[end_idx..], value))
```

**After:**
```rust
type Dest = NonZeroU32;
// ...
let value = u32::from_str_radix(&remaining[..end_idx], if is_hex { 16 } else { 10 })
    .map_err(|_| ())?;
let non_zero = NonZeroU32::new(value).ok_or(())?;
Ok((&remaining[end_idx..], non_zero))
```

This removes the three-line hint comment block and the `if value == 0` check, replacing them with a single `NonZeroU32::new(value).ok_or(())?` call that encodes the zero-rejection invariant directly in the return type.

A `use std::num::NonZeroU32;` import must be added inside the `mod stdp` block (after line 16).

### 2. `LogLine::request_id` -- Change field type from `u32` to `NonZeroU32`

**File:** `src/parse.rs`, line 1380

**Current:**
```rust
pub struct LogLine {
    pub kind: LogKind,
    pub request_id: u32,
}
```

**After:**
```rust
pub struct LogLine {
    pub kind: LogKind,
    pub request_id: std::num::NonZeroU32,
}
```

### 3. `Parsable` impl for `LogLine` -- Update associated type signature

**File:** `src/parse.rs`, line 1388

The `Map` combinator's function pointer type must change from `fn((LogKind, u32)) -> Self` to `fn((LogKind, std::num::NonZeroU32)) -> Self`.

**Current:**
```rust
impl Parsable for LogLine {
    type Parser = Map<
        All<(
            <LogKind as Parsable>::Parser,
            StripWhitespace<Preceded<Tag, stdp::U32>>,
        )>,
        fn((LogKind, u32)) -> Self,
    >;
    // ...
}
```

**After:**
```rust
impl Parsable for LogLine {
    type Parser = Map<
        All<(
            <LogKind as Parsable>::Parser,
            StripWhitespace<Preceded<Tag, stdp::U32>>,
        )>,
        fn((LogKind, std::num::NonZeroU32)) -> Self,
    >;
    // ...
}
```

The closure at line 1396 (`|(kind, request_id)| LogLine { kind, request_id }`) requires no change -- it simply forwards the now-`NonZeroU32` value into the struct field and continues to coerce to the updated function pointer type.

### 4. `read_log()` signature -- Change parameter type from `Vec<u32>` to `Vec<NonZeroU32>`

**File:** `src/lib.rs`, line 63

**Current:**
```rust
pub fn read_log(
    input: impl Read,
    mode: ReadMode,
    request_ids: Vec<u32>,
) -> Result<Vec<LogLine>, std::io::Error>
```

**After:**
```rust
pub fn read_log(
    input: impl Read,
    mode: ReadMode,
    request_ids: Vec<NonZeroU32>,
) -> Result<Vec<LogLine>, std::io::Error>
```

A `use std::num::NonZeroU32;` import must be added at the crate level (near line 3).

The filtering logic at line 69 (`request_ids.contains(&log.request_id)`) requires no code change -- `NonZeroU32` implements `PartialEq`, so `Vec<NonZeroU32>::contains()` works identically.

### 5. Test call sites -- Update to construct `NonZeroU32` values

#### 5a. `src/parse.rs` -- `test_u32` (lines 1424-1432)

Four assertions with expected `Ok(...)` values must wrap the expected integer in `NonZeroU32::new(...).unwrap()`. Three error assertions (`""`, `"-3"`, `"0x"`) remain unchanged.

**Current:**
```rust
assert_eq!(stdp::U32.parse("411"), Ok(("", 411)));
assert_eq!(stdp::U32.parse("411ab"), Ok(("ab", 411)));
assert_eq!(stdp::U32.parse("0x03"), Ok(("", 0x3)));
assert_eq!(stdp::U32.parse("0x03abg"), Ok(("g", 0x3ab)));
```

**After:**
```rust
use std::num::NonZeroU32;
assert_eq!(stdp::U32.parse("411"), Ok(("", NonZeroU32::new(411).unwrap())));
assert_eq!(stdp::U32.parse("411ab"), Ok(("ab", NonZeroU32::new(411).unwrap())));
assert_eq!(stdp::U32.parse("0x03"), Ok(("", NonZeroU32::new(0x3).unwrap())));
assert_eq!(stdp::U32.parse("0x03abg"), Ok(("g", NonZeroU32::new(0x3ab).unwrap())));
```

#### 5b. `src/lib.rs` -- `test_errors_mode` (lines 182-201)

- Line 184: `vec![1]` becomes `vec![NonZeroU32::new(1).unwrap()]`
- Line 189: `vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` becomes `(1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect()`

#### 5c. `src/lib.rs` -- `test_exchanges_mode` (lines 204-233)

- Line 208: `vec![1]` becomes `vec![NonZeroU32::new(1).unwrap()]`
- Line 213: `vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` becomes `(1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect()`

#### 5d. `src/lib.rs` -- `test_all` (lines 164-179)

Lines 166 and 171 use `vec![]` (empty vectors). These require no change -- type inference will automatically resolve `Vec<NonZeroU32>` from the updated `read_log()` signature.

#### 5e. `src/main.rs` -- No changes needed

Line 68 calls `read_log(file, analysis::ReadMode::All, vec![])`. The empty `vec![]` will infer the new type from the updated function signature. No modification required.

A `use std::num::NonZeroU32;` import is needed in the `lib.rs` test module. Since `lib.rs` already has `use super::*;` in `mod test`, adding the import at the crate level (Component 4) will make it available in tests automatically.

---

## API Contract

### Public types changed

| Type | Before | After | Breaking? |
|---|---|---|---|
| `stdp::U32::Dest` | `u32` | `NonZeroU32` | Yes (for callers of `stdp::U32.parse()`) |
| `LogLine::request_id` | `u32` | `NonZeroU32` | Yes (for code constructing/reading `LogLine`) |
| `read_log()` parameter | `Vec<u32>` | `Vec<NonZeroU32>` | Yes (for callers of `read_log()`) |

All breaking changes are acceptable per PRD constraint 5: "This is acceptable for this internal refactoring project."

### Unchanged surfaces

- `read_log()` return type: `Result<Vec<LogLine>, std::io::Error>` -- unchanged
- `LogLine` struct shape: same two fields (`kind`, `request_id`) -- only `request_id` type changes
- `LogKind`, `SystemLogKind`, `AppLogKind`, and all journal/trace/error types -- unchanged
- `stdp::I32` parser -- unchanged (out of scope per PRD constraint 4)
- `LogLineParser`, `LOG_LINE_PARSER`, `just_parse<T>()` -- unchanged
- `main.rs` -- unchanged (empty `vec![]` type-infers correctly)

### Internal consumers

A search for `request_id` across `src/` confirms exactly five usage sites:
1. `src/parse.rs:1380` -- struct field definition (changed)
2. `src/parse.rs:1396` -- parser closure constructing `LogLine` (no change needed -- type flows through)
3. `src/lib.rs:63` -- `read_log()` parameter (changed)
4. `src/lib.rs:69` -- filtering comparison (no change needed -- `NonZeroU32` implements `PartialEq`)
5. `src/parse.rs:1376` -- doc comment (no change needed)

---

## Data Flows

```
Log file / input stream
  |
  v
LogIterator::new(input) -> yields Result<LogLine, io::Error>
  |
  v
LOG_LINE_PARSER.parse(line) -> Result<(&str, LogLine), ()>
  |
  v  (inside LogLine's Parsable impl)
preceded(tag("requestid="), stdp::U32)
  |
  v  stdp::U32.parse(input):
  |    1. Parse digits -> u32 value
  |    2. NonZeroU32::new(value).ok_or(())?     <-- NEW: replaces if-check
  |    3. Return Ok((&remaining, NonZeroU32))
  |
  v
|(kind, request_id)| LogLine { kind, request_id }
  |                                   ^^^^^^^^^^
  |                          now NonZeroU32 instead of u32
  v
read_log() filtering:
  request_ids: Vec<NonZeroU32>
  request_ids.contains(&log.request_id)   <-- same logic, new types
  |
  v
Vec<LogLine> output
```

The data flow is functionally identical to the pre-refactoring version. The only difference is that `request_id` carries the `NonZeroU32` type through the entire chain, encoding the "never zero" invariant at the type level instead of relying on a runtime check.

---

## NFR (Non-Functional Requirements)

| Requirement | How Met |
|---|---|
| Zero external dependencies | No new crates. `std::num::NonZeroU32` is part of the standard library. |
| No behavior changes | Same input produces same output. Zero values are still rejected -- now by `NonZeroU32::new()` returning `None` instead of `if value == 0`. `Debug` output unchanged because `NonZeroU32`'s `Debug` impl prints the inner value directly. |
| No test deletions | All existing tests are preserved. Test assertions updated to use `NonZeroU32` expected values. Error test cases (`""`, `"-3"`, `"0x"`) remain identical. |
| Scope boundary | Changes limited to `stdp::U32` parser, `LogLine::request_id` field, `Parsable` impl for `LogLine`, `read_log()` parameter, and associated tests. `stdp::I32` is NOT modified. |
| Hint comment resolved | The three-line `// подсказка:` comment block at lines 37-39 of `parse.rs` is removed because the technical debt it identifies is resolved. |
| Conventions compliance | Follows `docs/conventions.md` "Idiomatic Rust" table: "Instead of `if value == 0 { return Err }` -> Use `NonZeroU32::new(value).ok_or(...)`". |

---

## Risks

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Test verbosity: constructing `NonZeroU32` values in tests requires `NonZeroU32::new(n).unwrap()` which is more verbose than bare integer literals. | High | Low | Use `(1..=10).map(\|n\| NonZeroU32::new(n).unwrap()).collect()` for multi-value vectors. Single-value vectors use `vec![NonZeroU32::new(1).unwrap()]`. If verbosity becomes excessive, define a test helper `fn nz(n: u32) -> NonZeroU32 { NonZeroU32::new(n).unwrap() }`. |
| `Parsable` impl type signature change: the associated `Parser` type contains `fn((LogKind, u32)) -> Self` which changes to `fn((LogKind, NonZeroU32)) -> Self`. | Low | Low | Direct substitution. The compiler enforces correctness. The closure at line 1396 continues to coerce to the function pointer type because it is non-capturing. |
| `main.rs` empty vector type inference: `vec![]` must infer `Vec<NonZeroU32>` from the updated `read_log()` signature. | Low | Low | Empty `vec![]` type-infers from the function parameter. If the compiler cannot infer, annotate as `Vec::<NonZeroU32>::new()`. |
| `Debug` output difference: `NonZeroU32`'s `Debug` impl might format differently than `u32`. | None | None | Verified: `NonZeroU32`'s `Debug` impl prints the inner `u32` value directly (e.g., `1`, not `NonZeroU32(1)`). Output is identical. |

---

## Deviations to Fix

**None.** The current codebase state matches the PRD's description exactly:

- `stdp::U32` has `type Dest = u32` at line 22 -- confirmed.
- The hint comment block is at lines 37-39 -- confirmed.
- The runtime zero check is at lines 40-42 -- confirmed.
- `LogLine::request_id` is `u32` at line 1380 -- confirmed.
- The `Parsable` impl for `LogLine` uses `fn((LogKind, u32)) -> Self` at line 1388 -- confirmed.
- `read_log()` accepts `Vec<u32>` at line 63 -- confirmed.
- Test call sites use bare integer literals -- confirmed.
- The `I32` parser is confirmed out of scope -- confirmed.
- No external dependencies exist in `Cargo.toml` -- confirmed.

No code deviates from requirements. No corrective tasks are needed.

---

## Implementation Tasks

### Task 11.1: Add `NonZeroU32` import and update `stdp::U32` parser

**File:** `src/parse.rs`, lines 14-45

1. Add `use std::num::NonZeroU32;` inside the `mod stdp` block (after `use super::Parser;` at line 16).
2. Change `type Dest = u32;` (line 22) to `type Dest = NonZeroU32;`.
3. Remove the three-line hint comment block (lines 37-39):
   ```rust
   // подсказка: вместо if можно использовать tight-тип std::num::NonZeroU32
   //            (ограничиться NonZeroU32::new(value).ok_or(()).get() - норм)
   //            или даже заиспользовать tightness
   ```
4. Remove the runtime zero check (lines 40-42):
   ```rust
   if value == 0 {
       return Err(()); // в наших логах нет нулей, ноль в операции - фикция
   }
   ```
5. Replace the above with:
   ```rust
   let non_zero = NonZeroU32::new(value).ok_or(())?;
   ```
6. Change the return value on line 43 from `value` to `non_zero`:
   ```rust
   Ok((&remaining[end_idx..], non_zero))
   ```

### Task 11.2: Update `LogLine` struct and `Parsable` impl

**File:** `src/parse.rs`, lines 1378-1399

1. Change `pub request_id: u32,` (line 1380) to `pub request_id: std::num::NonZeroU32,`.
2. Change `fn((LogKind, u32)) -> Self,` (line 1388) to `fn((LogKind, std::num::NonZeroU32)) -> Self,`.
3. The closure at line 1396 (`|(kind, request_id)| LogLine { kind, request_id }`) requires no change.

### Task 11.3: Update `read_log()` signature in `lib.rs`

**File:** `src/lib.rs`, line 63

1. Add `use std::num::NonZeroU32;` at the crate level (after `use std::io::Read;` at line 3).
2. Change `request_ids: Vec<u32>` to `request_ids: Vec<NonZeroU32>`.

### Task 11.4: Update test call sites

#### `src/parse.rs` -- `test_u32` (lines 1424-1432)

Add `use std::num::NonZeroU32;` inside the test function and update four assertions:

```rust
#[test]
fn test_u32() {
    use std::num::NonZeroU32;
    assert_eq!(stdp::U32.parse("411"), Ok(("", NonZeroU32::new(411).unwrap())));
    assert_eq!(stdp::U32.parse("411ab"), Ok(("ab", NonZeroU32::new(411).unwrap())));
    assert_eq!(stdp::U32.parse(""), Err(()));
    assert_eq!(stdp::U32.parse("-3"), Err(()));
    assert_eq!(stdp::U32.parse("0x03"), Ok(("", NonZeroU32::new(0x3).unwrap())));
    assert_eq!(stdp::U32.parse("0x03abg"), Ok(("g", NonZeroU32::new(0x3ab).unwrap())));
    assert_eq!(stdp::U32.parse("0x"), Err(()));
}
```

#### `src/lib.rs` -- `test_errors_mode` (lines 182-201)

```rust
// Line 184:
let errors_from_source1 = read_log(
    SOURCE1.as_bytes(),
    ReadMode::Errors,
    vec![NonZeroU32::new(1).unwrap()],
).unwrap();

// Line 189:
let all_ids: Vec<NonZeroU32> = (1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect();
```

#### `src/lib.rs` -- `test_exchanges_mode` (lines 204-233)

```rust
// Line 208:
let exchanges_from_source1 = read_log(
    SOURCE1.as_bytes(),
    ReadMode::Exchanges,
    vec![NonZeroU32::new(1).unwrap()],
).unwrap();

// Line 213:
let all_ids: Vec<NonZeroU32> = (1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect();
```

#### `src/lib.rs` -- `test_all` (lines 164-179)

No changes needed. Empty `vec![]` type-infers correctly.

#### `src/main.rs` -- No changes needed

Empty `vec![]` type-infers correctly from the updated `read_log()` signature.

### Task 11.5: Verify

Run the acceptance criteria:

```bash
cargo test                # All tests pass (no test cases deleted)
cargo run -- example.log  # Output identical to pre-refactoring
```

Additionally verify:

| Check | Expected |
|---|---|
| `type Dest = NonZeroU32;` in `stdp::U32` | Present |
| `NonZeroU32::new(value).ok_or(())?` in `stdp::U32` | Present |
| `pub request_id: std::num::NonZeroU32` in `LogLine` | Present |
| `fn((LogKind, std::num::NonZeroU32)) -> Self` in `Parsable` impl | Present |
| `request_ids: Vec<NonZeroU32>` in `read_log()` | Present |
| `// подсказка: вместо if можно использовать tight-тип` hint comment | Gone |
| `if value == 0 { return Err(()); }` runtime check | Gone |
| `use std::num::NonZeroU32;` import in `mod stdp` | Present |
| `use std::num::NonZeroU32;` import in `lib.rs` | Present |
| Test assertions use `NonZeroU32::new(...).unwrap()` | Present |
| Changes in `src/main.rs` | None |
| `stdp::I32` parser | Unchanged |
| External dependencies | Zero (unchanged) |
| Number of tests | Same as before (none deleted) |

---

## Open Questions

None. The phase specification is complete, the scope is well-defined, and the implementation path is clear. The single change -- replacing `u32` with `NonZeroU32` for `request_id` throughout the type chain -- has well-understood implications for the parser, struct definition, function signatures, and test assertions. No architectural decision record is needed because there is only one viable approach: `NonZeroU32` at the type level, which is the idiomatic Rust pattern for encoding non-zero invariants. The standard library provides the type and all necessary trait implementations (`Debug`, `Clone`, `PartialEq`, `Copy`, `Display`).
