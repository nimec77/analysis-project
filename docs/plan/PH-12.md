# Implementation Plan: PH-12 -- Remove `OnceLock` singleton

**Status:** PLAN_APPROVED
**Ticket:** PH-12 "Phase 12: Remove `OnceLock` singleton"
**PRD:** `docs/prd/PH-12.prd.md`
**Research:** `docs/research/PH-12.md`
**Phase spec:** `docs/phase/phase-12.md`

---

## Components

### 1. `LogLineParser` struct, impl, hints, and `LOG_LINE_PARSER` static -- Delete entirely

**File:** `src/parse.rs`, lines 1397-1413

The `LogLineParser` struct wraps a `std::sync::OnceLock` around the `LogLine` parser. The `pub static LOG_LINE_PARSER` is initialized lazily on first call. After Phase 1 (`String` -> `&str` migration), all parser combinators are lightweight stack-only structs with no heap allocations. The `OnceLock` caching is unnecessary.

**Current (lines 1397-1413):**
```rust
/// Парсер строки логов
pub struct LogLineParser {
    parser: std::sync::OnceLock<<LogLine as Parsable>::Parser>,
}
impl LogLineParser {
    pub fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, LogLine), ()> {
        self.parser
            .get_or_init(|| <LogLine as Parsable>::parser())
            .parse(input)
    }
}
// подсказка: singleton, без которого можно обойтись
// парсеры не страшно вытащить в pub
/// Единожды собранный парсер логов
pub static LOG_LINE_PARSER: LogLineParser = LogLineParser {
    parser: std::sync::OnceLock::new(),
};
```

**After:** All 17 lines are deleted. No replacement code is added in `parse.rs`. The blank line at line 1396 (between the `Parsable` impl for `LogLine` and the `#[cfg(test)]` block) is preserved as a separator.

This resolves the last remaining `// подсказка:` hint in the codebase:
- Line 1408: `// подсказка: singleton, без которого можно обойтись` ("hint: a singleton you can do without")
- Line 1409: `// парсеры не страшно вытащить в pub` ("parsers are safe to make pub")

### 2. `LogIterator<R>` struct -- Add `parser` field

**File:** `src/lib.rs`, lines 18-24

The `LogIterator<R>` struct currently has a single field (`lines`). A new field `parser: <LogLine as Parsable>::Parser` is added so that the parser is constructed once per iterator instance rather than accessed through a global static.

**Current (lines 18-24):**
```rust
struct LogIterator<R: Read> {
    #[allow(clippy::type_complexity)]
    lines: std::iter::Filter<
        std::io::Lines<std::io::BufReader<R>>,
        fn(&Result<String, std::io::Error>) -> bool,
    >,
}
```

**After:**
```rust
struct LogIterator<R: Read> {
    #[allow(clippy::type_complexity)]
    lines: std::iter::Filter<
        std::io::Lines<std::io::BufReader<R>>,
        fn(&Result<String, std::io::Error>) -> bool,
    >,
    parser: <LogLine as Parsable>::Parser,
}
```

The `<LogLine as Parsable>::Parser` associated type is fully concrete -- `Map<All<(...)>, fn(...) -> LogLine>` composed of stack-only combinator structs. It is directly usable as a struct field.

### 3. `LogIterator::new()` -- Initialize the `parser` field

**File:** `src/lib.rs`, lines 25-39

The constructor must initialize the new `parser` field by calling `LogLine::parser()`.

**Current (lines 28-38):**
```rust
        Self {
            lines: std::io::BufReader::with_capacity(4096, reader)
                .lines()
                .filter(|line_res| {
                    !line_res
                        .as_ref()
                        .ok()
                        .map(|line| line.trim().is_empty())
                        .unwrap_or(false)
                }),
        }
```

**After:**
```rust
        Self {
            lines: std::io::BufReader::with_capacity(4096, reader)
                .lines()
                .filter(|line_res| {
                    !line_res
                        .as_ref()
                        .ok()
                        .map(|line| line.trim().is_empty())
                        .unwrap_or(false)
                }),
            parser: LogLine::parser(),
        }
```

### 4. `LogIterator::next()` -- Replace global singleton call with local field

**File:** `src/lib.rs`, line 50

The single usage of `LOG_LINE_PARSER` is replaced with `self.parser`.

**Current (line 50):**
```rust
            let Ok((remaining, result)) = LOG_LINE_PARSER.parse(line.trim()) else {
```

**After:**
```rust
            let Ok((remaining, result)) = self.parser.parse(line.trim()) else {
```

---

## API Contract

### Public types removed

| Type | Status | Breaking? |
|---|---|---|
| `pub struct LogLineParser` | Deleted | Yes (for external code using this type) |
| `pub static LOG_LINE_PARSER: LogLineParser` | Deleted | Yes (for external code accessing this static) |

Both removals are acceptable per PRD constraint 6: "This is acceptable for this internal refactoring project. External consumers should use `<LogLine as Parsable>::parser()` directly."

### Unchanged surfaces

- `pub trait Parser` -- still public, method signature unchanged
- `pub trait Parsable` -- still public, method signature unchanged
- `pub struct LogLine` -- unchanged
- `impl Parsable for LogLine` -- unchanged, still provides `LogLine::parser()`
- `pub fn read_log(...)` -- unchanged signature and behavior
- `pub fn just_parse::<T>(...)` -- unchanged
- All data model types (`LogKind`, `SystemLogKind`, `AppLogKind`, etc.) -- unchanged
- `src/main.rs` -- no changes needed

### Internal consumers

Exactly **two** references to `LOG_LINE_PARSER` exist in source code:
1. `src/parse.rs:1411` -- definition site (deleted)
2. `src/lib.rs:50` -- usage site (replaced with `self.parser.parse(...)`)

No tests reference `LOG_LINE_PARSER` or `LogLineParser`. Test modifications are not needed.

---

## Data Flows

```
Log file / input stream
  |
  v
LogIterator::new(input):
  1. Constructs BufReader + lines iterator
  2. Constructs parser: LogLine::parser()     <-- NEW: replaces OnceLock singleton
  |
  v
LogIterator::next() loop:
  line = self.lines.next()
  |
  v
  self.parser.parse(line.trim())              <-- was: LOG_LINE_PARSER.parse(...)
  |
  v
  Result<(&str, LogLine), ()>
  |
  v
  if remaining.trim().is_empty() -> Some(Ok(result))
  else -> continue
  |
  v
read_log() filtering:
  request_ids, mode -> Vec<LogLine>
```

The data flow is functionally identical to the pre-refactoring version. The only structural difference is that the parser is constructed in `LogIterator::new()` and stored as a field, instead of being lazily initialized in a global `OnceLock` static. Parsing behavior, filtering, and output are unchanged.

---

## NFR (Non-Functional Requirements)

| Requirement | How Met |
|---|---|
| Zero external dependencies | No new crates. Code is only deleted. |
| No behavior changes | Same input produces same output. Parser construction is moved from a global `OnceLock` to a local field, but the parser logic is identical. |
| No test deletions | No test modifications are needed at all. Tests call `read_log()` which internally creates `LogIterator`. The structural change is invisible to tests. |
| Scope boundary | Changes limited to `LogLineParser`/`LOG_LINE_PARSER` deletion in `parse.rs` and `LogIterator` field addition in `lib.rs`. No other files modified. |
| Hint comment resolved | The two-line `// подсказка:` block at lines 1408-1409 is removed. This is the last remaining hint in the codebase. |
| Conventions compliance | Follows `docs/conventions.md` "Idiomatic Rust" table: "Instead of `OnceLock` singleton for parser -> Use Direct parser construction (zero-sized types)". |

---

## Risks

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Deeply nested parser type: `<LogLine as Parsable>::Parser` expands to a deeply nested combinator tree. | Medium | Low | The associated type syntax is used directly. The compiler handles the expansion. This is the same pattern used in every `Parsable` impl throughout `parse.rs`. |
| Parser construction cost per iterator: constructing the parser per `LogIterator` instance instead of once globally. | Low | Low | After Phase 1, all combinators are lightweight stack-only structs. `just_parse::<T>()` (PH-8) already constructs a parser per call without performance concerns. Construction is purely register/stack initialization with no heap allocation. |
| Glob import `use parse::*` silently absorbs the deletion. | Low | Low | The glob import also brings in `LogLine`, `LogKind`, `Parsable`, `Parser`, and all data model types. Removing two items has no effect on the import. |

---

## Deviations to Fix

**None.** The research document (Section 10) confirmed zero deviations. The current codebase state matches the PRD's description exactly:

- `LogLineParser` struct is at lines 1397-1399 of `src/parse.rs` -- confirmed.
- `impl LogLineParser` with `parse()` method is at lines 1401-1406 -- confirmed.
- Hint comments are at lines 1408-1409 -- confirmed.
- Doc comment is at line 1410 -- confirmed.
- `pub static LOG_LINE_PARSER` is at lines 1411-1413 -- confirmed.
- `LOG_LINE_PARSER.parse(line.trim())` is at line 50 of `src/lib.rs` -- confirmed.
- `LogIterator<R>` struct has one field (`lines`) at lines 18-24 of `src/lib.rs` -- confirmed.
- `LogIterator::new()` constructor is at lines 25-39 -- confirmed.
- `LogIterator::next()` is at lines 41-57 -- confirmed.
- No tests reference `LOG_LINE_PARSER` or `LogLineParser` -- confirmed.
- Phase 1 (prerequisite) is already complete -- confirmed.
- `Parsable` and `Parser` traits are already `pub` (PH-8) -- confirmed.

No corrective tasks are needed.

---

## Implementation Tasks

### Task 12.1: Delete `LogLineParser` struct, impl, hints, and `LOG_LINE_PARSER` static from `parse.rs`

**File:** `src/parse.rs`, lines 1397-1413

Delete the following 17 lines entirely:

```rust
/// Парсер строки логов
pub struct LogLineParser {
    parser: std::sync::OnceLock<<LogLine as Parsable>::Parser>,
}
impl LogLineParser {
    pub fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, LogLine), ()> {
        self.parser
            .get_or_init(|| <LogLine as Parsable>::parser())
            .parse(input)
    }
}
// подсказка: singleton, без которого можно обойтись
// парсеры не страшно вытащить в pub
/// Единожды собранный парсер логов
pub static LOG_LINE_PARSER: LogLineParser = LogLineParser {
    parser: std::sync::OnceLock::new(),
};
```

Preserve the blank line at line 1396 as a separator before `#[cfg(test)]`.

### Task 12.2: Add `parser` field to `LogIterator<R>` struct in `lib.rs`

**File:** `src/lib.rs`, lines 18-24

Add the following field after the `lines` field:

```rust
    parser: <LogLine as Parsable>::Parser,
```

No new imports are needed. `LogLine`, `Parsable`, and `Parser` are already imported via `use parse::*;`.

### Task 12.3: Initialize `parser` field in `LogIterator::new()`

**File:** `src/lib.rs`, lines 25-39

Add the following initialization after the `lines` field in the `Self { ... }` struct literal:

```rust
            parser: LogLine::parser(),
```

### Task 12.4: Replace `LOG_LINE_PARSER.parse(...)` with `self.parser.parse(...)` in `LogIterator::next()`

**File:** `src/lib.rs`, line 50

Change:
```rust
            let Ok((remaining, result)) = LOG_LINE_PARSER.parse(line.trim()) else {
```
To:
```rust
            let Ok((remaining, result)) = self.parser.parse(line.trim()) else {
```

### Task 12.5: Verify

Run the acceptance criteria:

```bash
cargo test                # All tests pass (no test cases deleted)
cargo run -- example.log  # Output identical to pre-refactoring
```

Additionally verify:

| Check | Expected |
|---|---|
| `LogLineParser` struct in `src/parse.rs` | Deleted |
| `pub static LOG_LINE_PARSER` in `src/parse.rs` | Deleted |
| `std::sync::OnceLock` usage in `src/parse.rs` | Zero |
| `// подсказка: singleton, без которого можно обойтись` in `src/parse.rs` | Gone |
| `// парсеры не страшно вытащить в pub` in `src/parse.rs` | Gone |
| `/// Единожды собранный парсер логов` in `src/parse.rs` | Gone |
| `LOG_LINE_PARSER` references in `src/lib.rs` | Zero |
| `parser: <LogLine as Parsable>::Parser` field in `LogIterator` | Present |
| `parser: LogLine::parser()` in `LogIterator::new()` | Present |
| `self.parser.parse(line.trim())` in `LogIterator::next()` | Present |
| Changes in `src/main.rs` | None |
| Changes in test code | None |
| External dependencies | Zero (unchanged) |
| Number of tests | Same as before (none deleted) |

---

## Open Questions

None. The phase specification is complete, the scope is well-defined, and the implementation path is clear. This is the final phase (12 of 12) and the simplest in scope: a 17-line deletion in `parse.rs` and a mechanical field-addition in `lib.rs`. No architectural decision record is needed because there is only one viable approach -- storing the parser as a field in `LogIterator` -- which is explicitly recommended by the PRD and confirmed as correct by the research document. No alternative designs exist that would warrant an ADR.
