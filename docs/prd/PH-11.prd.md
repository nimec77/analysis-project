# PRD: Phase 11 — `NonZeroU32` tight type

**Status:** PRD_READY
**Ticket:** PH-11 "Phase 11: `NonZeroU32` tight type"
**Phase:** 11 of 12 (see `docs/tasklist.md`)
**Dependencies:** None (independent phase)
**Blocked by:** Nothing
**Blocks:** None directly (downstream phases are independent)

---

## Context / Idea

Phase 11 replaces the `u32` type used for `request_id` with `std::num::NonZeroU32`, encoding the "no-zero-IDs" invariant directly in the type system rather than enforcing it with a runtime `if value == 0 { return Err(()); }` check.

The `stdp::U32` parser in `src/parse.rs` (lines 20-45) currently parses an unsigned integer and then performs a runtime check to reject zero values:

```rust
// подсказка: вместо if можно использовать tight-тип std::num::NonZeroU32
//            (ограничиться NonZeroU32::new(value).ok_or(()).get() - норм)
//            или даже заиспользовать tightness
if value == 0 {
    return Err(()); // в наших логах нет нулей, ноль в операции - фикция
}
```

The hint left by the original author explicitly recommends switching to `NonZeroU32::new(value).ok_or(())` to replace the `if` check with a type-level guarantee. This means the parsed value is immediately wrapped in `NonZeroU32`, and the zero-rejection is handled by `NonZeroU32::new()` returning `None` for zero.

The `request_id` field in `LogLine` (line 1380) is currently `pub request_id: u32`, and the `read_log()` function in `src/lib.rs` (line 63) accepts `request_ids: Vec<u32>` for filtering. Both of these must change to use `NonZeroU32` to maintain type consistency.

### Authoritative specification from `docs/phase/phase-11.md`

**Goal:** Use `std::num::NonZeroU32` for `request_id` instead of `u32` + runtime check.

**Tasks:**

- [ ] 11.1 Use `std::num::NonZeroU32` for `request_id` instead of `u32` + runtime check

**Acceptance Criteria:** `cargo test && cargo run -- example.log`

**Dependencies:** None (independent phase)

**Implementation Notes:**

- **Hint:** `src/parse.rs:39` -- `// подсказка: вместо if можно использовать tight-тип std::num::NonZeroU32`

### Current codebase state (gap analysis)

The `stdp::U32` parser at line 20 of `src/parse.rs` currently has `type Dest = u32` and returns a `u32` after a runtime zero-check:

```rust
pub struct U32;
impl Parser for U32 {
    type Dest = u32;
    fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, Self::Dest), ()> {
        // ... parsing logic ...
        let value = u32::from_str_radix(&remaining[..end_idx], if is_hex { 16 } else { 10 })
            .map_err(|_| ())?;
        // подсказка: вместо if можно использовать tight-тип std::num::NonZeroU32
        if value == 0 {
            return Err(());
        }
        Ok((&remaining[end_idx..], value))
    }
}
```

The `LogLine` struct at line 1378 stores the parsed result as `u32`:

```rust
pub struct LogLine {
    pub kind: LogKind,
    pub request_id: u32,
}
```

The `Parsable` impl for `LogLine` at line 1382 uses `stdp::U32` and the function signature references `u32`:

```rust
impl Parsable for LogLine {
    type Parser = Map<
        All<(
            <LogKind as Parsable>::Parser,
            StripWhitespace<Preceded<Tag, stdp::U32>>,
        )>,
        fn((LogKind, u32)) -> Self,
    >;
    fn parser() -> Self::Parser {
        map(
            all2(
                LogKind::parser(),
                strip_whitespace(preceded(tag("requestid="), stdp::U32)),
            ),
            |(kind, request_id)| LogLine { kind, request_id },
        )
    }
}
```

The `read_log()` function in `src/lib.rs` at line 60 accepts `Vec<u32>` for filtering:

```rust
pub fn read_log(
    input: impl Read,
    mode: ReadMode,
    request_ids: Vec<u32>,
) -> Result<Vec<LogLine>, std::io::Error> {
```

And the filtering comparison at line 69 uses `request_ids.contains(&log.request_id)`.

Test call sites in `src/lib.rs` pass `vec![1]`, `vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`, etc. as `u32` literals. These must be changed to `NonZeroU32` values.

---

## Goals

1. **Replace `u32` with `NonZeroU32` in the `stdp::U32` parser.** Change `type Dest` from `u32` to `std::num::NonZeroU32`. Replace the runtime `if value == 0 { return Err(()); }` check with `NonZeroU32::new(value).ok_or(())?`, encoding the zero-rejection invariant in the return type.

2. **Update `LogLine::request_id` from `u32` to `NonZeroU32`.** The `request_id` field in the `LogLine` struct must change to `pub request_id: std::num::NonZeroU32` to reflect the parsed type.

3. **Update the `Parsable` impl for `LogLine`.** The associated `Parser` type signature contains `fn((LogKind, u32)) -> Self` which must change to `fn((LogKind, NonZeroU32)) -> Self`.

4. **Update `read_log()` signature in `src/lib.rs`.** The `request_ids` parameter must change from `Vec<u32>` to `Vec<NonZeroU32>` so that the filtering comparison `request_ids.contains(&log.request_id)` remains type-consistent.

5. **Update all test call sites.** Tests in `src/lib.rs` that pass `vec![1]` or `vec![1, 2, 3, 4, ...]` must construct `NonZeroU32` values (e.g., `NonZeroU32::new(1).unwrap()` or using the `nonzero!` macro if available). Tests in `src/parse.rs` for `stdp::U32` must update expected values from `Ok(("", 411))` to `Ok(("", NonZeroU32::new(411).unwrap()))`.

6. **Remove the hint comments.** The three-line `// подсказка:` comment block at lines 37-39 of `src/parse.rs` and the associated `if value == 0` check and its comment at lines 40-42 should be removed, as the technical debt they identify will be resolved.

7. **Preserve all existing behavior.** The `NonZeroU32` change is purely a type tightening. All parsing, filtering, and output must remain identical. All existing tests must pass.

---

## User Stories

1. **As a maintainer of the log parser**, I want `request_id` to be typed as `NonZeroU32` instead of `u32`, so that the "request IDs are never zero" invariant is enforced by the compiler rather than relying on a runtime `if` check that could be accidentally removed.

2. **As a Rust developer reading this codebase**, I want the type of `request_id` to communicate that zero is not a valid value, so that I do not need to read the parser internals to understand this domain constraint.

3. **As a contributor adding new features that use `request_id`**, I want the type system to prevent me from accidentally constructing or passing a zero request ID, reducing the surface area for bugs in filtering and lookup logic.

---

## Scenarios

### Scenario 1: `stdp::U32` parser returns `NonZeroU32`

**Before:**
```rust
pub struct U32;
impl Parser for U32 {
    type Dest = u32;
    fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, Self::Dest), ()> {
        // ... parsing ...
        let value = u32::from_str_radix(...).map_err(|_| ())?;
        if value == 0 {
            return Err(());
        }
        Ok((&remaining[end_idx..], value))
    }
}
```

**After:**
```rust
use std::num::NonZeroU32;

pub struct U32;
impl Parser for U32 {
    type Dest = NonZeroU32;
    fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, Self::Dest), ()> {
        // ... parsing ...
        let value = u32::from_str_radix(...).map_err(|_| ())?;
        let non_zero = NonZeroU32::new(value).ok_or(())?;
        Ok((&remaining[end_idx..], non_zero))
    }
}
```

### Scenario 2: `LogLine::request_id` becomes `NonZeroU32`

**Before:**
```rust
pub struct LogLine {
    pub kind: LogKind,
    pub request_id: u32,
}
```

**After:**
```rust
use std::num::NonZeroU32;

pub struct LogLine {
    pub kind: LogKind,
    pub request_id: NonZeroU32,
}
```

### Scenario 3: `Parsable` impl for `LogLine` updated

**Before:**
```rust
impl Parsable for LogLine {
    type Parser = Map<
        All<(
            <LogKind as Parsable>::Parser,
            StripWhitespace<Preceded<Tag, stdp::U32>>,
        )>,
        fn((LogKind, u32)) -> Self,
    >;
    // ...
}
```

**After:**
```rust
impl Parsable for LogLine {
    type Parser = Map<
        All<(
            <LogKind as Parsable>::Parser,
            StripWhitespace<Preceded<Tag, stdp::U32>>,
        )>,
        fn((LogKind, NonZeroU32)) -> Self,
    >;
    // ...
}
```

### Scenario 4: `read_log()` signature updated

**Before:**
```rust
pub fn read_log(
    input: impl Read,
    mode: ReadMode,
    request_ids: Vec<u32>,
) -> Result<Vec<LogLine>, std::io::Error>
```

**After:**
```rust
use std::num::NonZeroU32;

pub fn read_log(
    input: impl Read,
    mode: ReadMode,
    request_ids: Vec<NonZeroU32>,
) -> Result<Vec<LogLine>, std::io::Error>
```

### Scenario 5: Test assertions updated

**Before (parse.rs):**
```rust
assert_eq!(stdp::U32.parse("411"), Ok(("", 411)));
assert_eq!(stdp::U32.parse("0x03"), Ok(("", 0x3)));
```

**After (parse.rs):**
```rust
use std::num::NonZeroU32;
assert_eq!(stdp::U32.parse("411"), Ok(("", NonZeroU32::new(411).unwrap())));
assert_eq!(stdp::U32.parse("0x03"), Ok(("", NonZeroU32::new(0x3).unwrap())));
```

**Before (lib.rs):**
```rust
let errors_from_source1 = read_log(SOURCE1.as_bytes(), ReadMode::Errors, vec![1]).unwrap();
let all_ids = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
```

**After (lib.rs):**
```rust
use std::num::NonZeroU32;
let errors_from_source1 = read_log(
    SOURCE1.as_bytes(),
    ReadMode::Errors,
    vec![NonZeroU32::new(1).unwrap()],
).unwrap();
let all_ids: Vec<NonZeroU32> = (1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect();
```

### Scenario 6: Hint comments removed

**Before:**
```rust
// подсказка: вместо if можно использовать tight-тип std::num::NonZeroU32
//            (ограничиться NonZeroU32::new(value).ok_or(()).get() - норм)
//            или даже заиспользовать tightness
if value == 0 {
    return Err(()); // в наших логах нет нулей, ноль в операции - фикция
}
```

**After:**
```rust
let non_zero = NonZeroU32::new(value).ok_or(())?;
```

The three-line hint comment block and the `if value == 0` check with its inline comment are all removed, replaced by the single `NonZeroU32::new(value).ok_or(())?` call.

---

## Metrics

| Metric | Target |
|---|---|
| `cargo test` | All tests pass (no test cases deleted) |
| `cargo run -- example.log` | Output identical to pre-refactoring |
| `LogLine::request_id` type | `std::num::NonZeroU32` (was `u32`) |
| `stdp::U32::Dest` type | `std::num::NonZeroU32` (was `u32`) |
| `read_log()` `request_ids` parameter type | `Vec<NonZeroU32>` (was `Vec<u32>`) |
| Runtime `if value == 0` check in `stdp::U32` | Removed, replaced by `NonZeroU32::new().ok_or()` |
| Hint comment `подсказка: вместо if можно использовать tight-тип` | Removed |
| Zero-value `request_id` rejection | Still rejected (now at type level via `NonZeroU32::new()` returning `None`) |

---

## Constraints

1. **Zero external dependencies.** No new crates in `Cargo.toml`. `std::num::NonZeroU32` is part of the standard library.
2. **No behavior changes.** The type tightening must not alter any observable behavior. Zero values are already rejected; the change only moves the enforcement from a runtime `if` check to the type system.
3. **No test deletions.** Existing tests are updated to use `NonZeroU32` values in expected results and call sites but are not deleted or reduced in coverage.
4. **Scope boundary.** This phase changes only the `stdp::U32` parser's `Dest` type, the `LogLine::request_id` field type, the `read_log()` parameter type, the `Parsable` impl for `LogLine`, and associated tests. The `stdp::I32` parser is not changed (it remains `i32`), as `request_id` is the only field affected.
5. **Public API change.** `LogLine` is a public struct with public fields. Changing `request_id: u32` to `request_id: NonZeroU32` is a breaking change for any external code that constructs `LogLine` values or reads `request_id` as `u32`. This is acceptable for this internal refactoring project.
6. **Debug output.** `NonZeroU32` implements `Debug` and prints as the inner `u32` value (e.g., `NonZeroU32(1)` in debug output, or simply `1` for display). The `{:?}` output in `main.rs` will show `request_id: 1` because `NonZeroU32`'s `Debug` impl prints the inner value. If the debug output format changes slightly, this is acceptable.

---

## Risks

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Test verbosity: constructing `NonZeroU32` values in tests requires `NonZeroU32::new(n).unwrap()` which is more verbose than bare integer literals. | High | Low | Use helper patterns like `(1..=10).map(\|n\| NonZeroU32::new(n).unwrap()).collect()` to reduce repetition. Alternatively, define a small test helper function `fn nz(n: u32) -> NonZeroU32 { NonZeroU32::new(n).unwrap() }` if verbosity becomes excessive. |
| `Parsable` impl type signature change: the `Map` combinator's function pointer type in `LogLine`'s `Parsable` impl changes from `fn((LogKind, u32)) -> Self` to `fn((LogKind, NonZeroU32)) -> Self`. This is a straightforward type substitution. | Low | Low | Direct substitution of `u32` with `NonZeroU32` in the associated type. The compiler will enforce correctness. |
| `main.rs` call site: `read_log(file, ReadMode::All, vec![])` passes an empty `Vec`. Since `vec![]` is type-inferred, changing the parameter type to `Vec<NonZeroU32>` should be inferred automatically. | Low | Low | The empty `vec![]` will infer the new type from the function signature. No change needed in `main.rs` unless the compiler cannot infer the type, in which case `vec![]` can be annotated as `Vec::<NonZeroU32>::new()`. |
| `Debug` output change: `NonZeroU32`'s `Debug` impl may produce slightly different formatting than `u32` (e.g., the output might not change at all since `NonZeroU32`'s `Debug` just delegates to the inner `u32`). | Low | Low | Verify `cargo run -- example.log` output. `NonZeroU32`'s `Debug` impl prints the inner value directly, so output should be identical. |

---

## Open Questions

None. The phase specification is complete, the scope is well-defined, and the implementation path is clear. The single change -- replacing `u32` with `NonZeroU32` for `request_id` throughout the type chain -- has well-understood implications for the parser, struct definition, function signatures, and test assertions.

---

## Files Affected

| File | Changes |
|---|---|
| `src/parse.rs` | Change `stdp::U32`'s `type Dest` from `u32` to `NonZeroU32` (line 22). Replace the `if value == 0` runtime check (lines 40-42) with `NonZeroU32::new(value).ok_or(())?`. Remove the three-line hint comment block (lines 37-39). Change `LogLine::request_id` from `u32` to `NonZeroU32` (line 1380). Update `Parsable` impl for `LogLine`: change `fn((LogKind, u32)) -> Self` to `fn((LogKind, NonZeroU32)) -> Self` (line 1388). Update `test_u32` assertions to expect `NonZeroU32` values (lines 1425-1431). Add `use std::num::NonZeroU32;` import. |
| `src/lib.rs` | Change `read_log()` parameter `request_ids: Vec<u32>` to `request_ids: Vec<NonZeroU32>` (line 63). Update test call sites to construct `NonZeroU32` values in `vec![]` arguments (lines 184, 189, 208, 213). Add `use std::num::NonZeroU32;` import. |
