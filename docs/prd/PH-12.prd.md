# PRD: Phase 12 — Remove `OnceLock` singleton

**Status:** PRD_READY
**Ticket:** PH-12 "Phase 12: Remove `OnceLock` singleton"
**Phase:** 12 of 12 (see `docs/tasklist.md`)
**Dependencies:** Phase 1 (lightweight parser construction after `&str` migration)
**Blocked by:** Nothing (Phase 1 is already complete)
**Blocks:** None (this is the final phase)

---

## Context / Idea

Phase 12 removes the `LOG_LINE_PARSER` `OnceLock` singleton from `src/parse.rs`, constructing the parser inline or passing it as a parameter instead.

The `LogLineParser` struct at line 1398 of `src/parse.rs` wraps the parser in a `std::sync::OnceLock`, deferring construction until first use and caching the result for subsequent calls:

```rust
/// Парсер строки логов
pub struct LogLineParser {
    parser: std::sync::OnceLock<<LogLine as Parsable>::Parser>,
}
impl LogLineParser {
    pub fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, LogLine), ()> {
        self.parser
            .get_or_init(|| <LogLine as Parsable>::parser())
            .parse(input)
    }
}
// подсказка: singleton, без которого можно обойтись
// парсеры не страшно вытащить в pub
/// Единожды собранный парсер логов
pub static LOG_LINE_PARSER: LogLineParser = LogLineParser {
    parser: std::sync::OnceLock::new(),
};
```

This singleton pattern was originally necessary when parsers held owned `String` values and construction was expensive. After Phase 1 (`String` -> `&str` migration), all parser combinator structs store only `&'static str` references and zero-sized type markers. Parser construction via `<LogLine as Parsable>::parser()` is now a cheap, purely stack-based operation with no heap allocations. The `OnceLock` caching is unnecessary overhead and adds conceptual complexity (global mutable state, synchronization primitives) for no measurable benefit.

The hint left by the original author explicitly identifies this as removable:
- `src/parse.rs:1408` -- `// подсказка: singleton, без которого можно обойтись` ("hint: a singleton you can do without")
- `src/parse.rs:1409` -- `// парсеры не страшно вытащить в pub` ("parsers are safe to make pub")

The sole consumer of `LOG_LINE_PARSER` is `LogIterator::next()` in `src/lib.rs` (line 50):

```rust
let Ok((remaining, result)) = LOG_LINE_PARSER.parse(line.trim()) else {
    continue;
};
```

### Authoritative specification from `docs/phase/phase-12.md`

**Goal:** Remove the `LOG_LINE_PARSER` `OnceLock` singleton, constructing the parser inline or passing it as a parameter.

**Tasks:**

- [ ] 12.1 Remove `LOG_LINE_PARSER` `OnceLock` singleton
- [ ] 12.2 Construct the parser inline or pass it as a parameter
- [ ] 12.3 Update call site in `lib.rs`

**Acceptance Criteria:** `cargo test && cargo run -- example.log`

**Dependencies:** Phase 1 complete (lightweight parser construction after `&str` migration)

**Implementation Notes:**

- **Hint:** `src/parse.rs:1144` -- `// подсказка: singleton, без которого можно обойтись`

### Current codebase state (gap analysis)

The `LogLineParser` struct at line 1398 of `src/parse.rs` wraps an `OnceLock` around the parser type:

```rust
pub struct LogLineParser {
    parser: std::sync::OnceLock<<LogLine as Parsable>::Parser>,
}
```

The `pub static LOG_LINE_PARSER` at line 1411 is the global singleton, constructed with `OnceLock::new()` and lazily initialized on first `parse()` call via `get_or_init()`.

The `LogIterator<R>` struct in `src/lib.rs` imports and uses `LOG_LINE_PARSER` at line 50 inside its `Iterator::next()` implementation. It does not store a parser instance -- it references the global static on every call to `next()`.

Since `Parsable::parser()` returns a value type (not a reference) and all combinators are lightweight structs, the parser can be constructed once per `LogIterator` instance and stored as a field, or constructed fresh on each `next()` call. Storing it as a field in `LogIterator` is the cleaner approach -- it constructs the parser once when the iterator is created and reuses it for every line.

---

## Goals

1. **Remove the `LogLineParser` struct and `LOG_LINE_PARSER` static.** Delete the `LogLineParser` struct definition (lines 1397-1406), the hint comments (lines 1408-1409), the doc comment (line 1410), and the `pub static LOG_LINE_PARSER` declaration (lines 1411-1413) from `src/parse.rs`.

2. **Construct the parser locally instead of using a global singleton.** In `src/lib.rs`, construct the `LogLine` parser via `<LogLine as Parsable>::parser()` (or equivalently `LogLine::parser()`) and store it as a field in `LogIterator`, or construct it inline at the call site. The preferred approach is to store it as a field in `LogIterator<R>` so it is built once per iterator and reused across all `next()` calls.

3. **Update the call site in `LogIterator::next()`.** Replace `LOG_LINE_PARSER.parse(line.trim())` with a call to the locally-stored or locally-constructed parser's `.parse()` method.

4. **Remove the hint comments.** The two-line hint comment block (`// подсказка: singleton, без которого можно обойтись` and `// парсеры не страшно вытащить в pub`) and the doc comment (`/// Единожды собранный парсер логов`) at lines 1408-1410 should be removed, as the technical debt they identify will be resolved.

5. **Preserve all existing behavior.** Removing the singleton is purely a structural refactoring. All parsing, filtering, and output must remain identical. All existing tests must pass.

---

## User Stories

1. **As a maintainer of the log parser**, I want the `OnceLock` singleton removed so that there is no hidden global mutable state, making the code easier to reason about and test in isolation.

2. **As a Rust developer reading this codebase**, I want the parser to be constructed at its point of use rather than accessed through a global static, so that the data flow is explicit and I can trace parser ownership without consulting a `pub static` declaration.

3. **As a contributor adding new features**, I want the `LogLineParser` wrapper struct removed so that there is one fewer layer of indirection between the `Parsable` trait and the actual parsing call, simplifying the mental model of how parsing works.

4. **As an author of concurrent or async extensions**, I want the `std::sync::OnceLock` dependency removed so that the parser infrastructure does not introduce synchronization primitives unnecessarily, keeping the codebase free of concurrency concerns where none are needed.

---

## Scenarios

### Scenario 1: `LogLineParser` struct and `LOG_LINE_PARSER` static removed from `parse.rs`

**Before:**
```rust
/// Парсер строки логов
pub struct LogLineParser {
    parser: std::sync::OnceLock<<LogLine as Parsable>::Parser>,
}
impl LogLineParser {
    pub fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, LogLine), ()> {
        self.parser
            .get_or_init(|| <LogLine as Parsable>::parser())
            .parse(input)
    }
}
// подсказка: singleton, без которого можно обойтись
// парсеры не страшно вытащить в pub
/// Единожды собранный парсер логов
pub static LOG_LINE_PARSER: LogLineParser = LogLineParser {
    parser: std::sync::OnceLock::new(),
};
```

**After:**
The entire `LogLineParser` struct, its `impl` block, the hint comments, the doc comment, and the `pub static LOG_LINE_PARSER` declaration are all deleted. No replacement code is added in `parse.rs`.

### Scenario 2: `LogIterator` stores the parser as a field

**Before (`lib.rs`):**
```rust
struct LogIterator<R: Read> {
    #[allow(clippy::type_complexity)]
    lines: std::iter::Filter<
        std::io::Lines<std::io::BufReader<R>>,
        fn(&Result<String, std::io::Error>) -> bool,
    >,
}
impl<R: Read> LogIterator<R> {
    fn new(reader: R) -> Self {
        use std::io::BufRead;
        Self {
            lines: std::io::BufReader::with_capacity(4096, reader)
                .lines()
                .filter(|line_res| { /* ... */ }),
        }
    }
}
```

**After (`lib.rs`):**
```rust
struct LogIterator<R: Read> {
    #[allow(clippy::type_complexity)]
    lines: std::iter::Filter<
        std::io::Lines<std::io::BufReader<R>>,
        fn(&Result<String, std::io::Error>) -> bool,
    >,
    parser: <LogLine as Parsable>::Parser,
}
impl<R: Read> LogIterator<R> {
    fn new(reader: R) -> Self {
        use std::io::BufRead;
        Self {
            lines: std::io::BufReader::with_capacity(4096, reader)
                .lines()
                .filter(|line_res| { /* ... */ }),
            parser: LogLine::parser(),
        }
    }
}
```

### Scenario 3: `LogIterator::next()` uses the local parser field

**Before (`lib.rs`):**
```rust
impl<R: Read> Iterator for LogIterator<R> {
    type Item = Result<parse::LogLine, std::io::Error>;
    fn next(&mut self) -> Option<Self::Item> {
        loop {
            let line_result = self.lines.next()?;
            let line = match line_result {
                Ok(line) => line,
                Err(e) => return Some(Err(e)),
            };
            let Ok((remaining, result)) = LOG_LINE_PARSER.parse(line.trim()) else {
                continue;
            };
            if remaining.trim().is_empty() {
                return Some(Ok(result));
            }
        }
    }
}
```

**After (`lib.rs`):**
```rust
impl<R: Read> Iterator for LogIterator<R> {
    type Item = Result<parse::LogLine, std::io::Error>;
    fn next(&mut self) -> Option<Self::Item> {
        loop {
            let line_result = self.lines.next()?;
            let line = match line_result {
                Ok(line) => line,
                Err(e) => return Some(Err(e)),
            };
            let Ok((remaining, result)) = self.parser.parse(line.trim()) else {
                continue;
            };
            if remaining.trim().is_empty() {
                return Some(Ok(result));
            }
        }
    }
}
```

### Scenario 4: No import of `LOG_LINE_PARSER` needed

**Before (`lib.rs`):**
```rust
use parse::*;
// This glob import brings in LOG_LINE_PARSER
```

**After (`lib.rs`):**
```rust
use parse::*;
// LOG_LINE_PARSER no longer exists; LogLine and Parsable are still
// imported via the glob and used to construct the parser locally
```

The `use parse::*;` glob import remains unchanged but no longer imports `LOG_LINE_PARSER` (since it has been deleted). The `Parsable` trait and `LogLine` struct (both already public) are still imported and used to call `LogLine::parser()`.

---

## Metrics

| Metric | Target |
|---|---|
| `cargo test` | All tests pass (no test cases deleted) |
| `cargo run -- example.log` | Output identical to pre-refactoring |
| `std::sync::OnceLock` usage in `src/parse.rs` | Zero (removed) |
| `LogLineParser` struct in `src/parse.rs` | Deleted |
| `pub static LOG_LINE_PARSER` in `src/parse.rs` | Deleted |
| `LOG_LINE_PARSER` references in `src/lib.rs` | Zero (replaced with local parser field) |
| Hint comment `подсказка: singleton, без которого можно обойтись` | Removed |
| Hint comment `парсеры не страшно вытащить в pub` | Removed |
| Parser construction location | `LogIterator::new()` in `src/lib.rs` (once per iterator instance) |

---

## Constraints

1. **Zero external dependencies.** No new crates in `Cargo.toml`. The change only removes a dependency on `std::sync::OnceLock`.
2. **No behavior changes.** Removing the singleton is purely structural. All parsing, filtering, and output must remain identical.
3. **No test deletions.** Existing tests are not deleted or reduced in coverage. No test modifications are expected since no tests directly reference `LOG_LINE_PARSER`.
4. **Scope boundary.** This phase changes only the `LogLineParser` struct and `LOG_LINE_PARSER` static in `src/parse.rs`, and the `LogIterator` struct and its `next()` method in `src/lib.rs`. No other files or types are affected.
5. **Parser type must be expressible.** The `<LogLine as Parsable>::Parser` associated type must be usable as a struct field. Since all parser combinator types are concrete (not trait objects) and the `Parsable` trait is implemented with a concrete associated type, this is straightforward.
6. **Public API change.** Removing `pub static LOG_LINE_PARSER` and `pub struct LogLineParser` is a breaking change for any external code that uses these items. This is acceptable for this internal refactoring project. External consumers should use `<LogLine as Parsable>::parser()` directly.

---

## Risks

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| The `<LogLine as Parsable>::Parser` type is deeply nested and may produce a complex type signature for the `LogIterator` field. | Medium | Low | Use the associated type syntax `<LogLine as Parsable>::Parser` directly as the field type. The compiler handles the expansion. The type does not need to be spelled out manually. |
| Constructing the parser per-iterator instead of once globally could have a performance impact if parser construction is not truly cheap. | Low | Low | After Phase 1, all combinators store only `&'static str` references and zero-sized types. Construction is pure stack initialization with no heap allocation. Constructing once per `LogIterator` (i.e., once per `read_log()` call) is negligible overhead. |
| Tests in `parse.rs` might reference `LOG_LINE_PARSER` directly. | Low | Low | Verified: `LOG_LINE_PARSER` is referenced only at its definition site in `parse.rs` (line 1411) and at its usage site in `lib.rs` (line 50). No tests reference it. |
| The glob import `use parse::*` in `lib.rs` may cause a compilation warning or error if `LOG_LINE_PARSER` was the only item being used from that import. | Low | Low | The glob import also brings in `LogLine`, `LogKind`, `Parsable`, `Parser`, and all data model types used extensively in `lib.rs`. Removing one item has no effect on the import. |

---

## Open Questions

None. The phase specification is complete, the scope is well-defined, and the implementation path is clear. Phase 1 (the prerequisite) is already complete, confirming that parser construction is lightweight. The single change -- removing the `OnceLock` singleton and constructing the parser locally in `LogIterator` -- has well-understood implications limited to two files.

---

## Files Affected

| File | Changes |
|---|---|
| `src/parse.rs` | Delete the `LogLineParser` struct (lines 1397-1406). Delete the `impl LogLineParser` block (lines 1401-1406). Delete the hint comments and doc comment (lines 1408-1410). Delete `pub static LOG_LINE_PARSER` declaration (lines 1411-1413). |
| `src/lib.rs` | Add a `parser: <LogLine as Parsable>::Parser` field to `LogIterator<R>`. Initialize it with `LogLine::parser()` in `LogIterator::new()`. Replace `LOG_LINE_PARSER.parse(line.trim())` with `self.parser.parse(line.trim())` in `LogIterator::next()`. |
