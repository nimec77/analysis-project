# Research: PH-11 — `NonZeroU32` tight type

**Ticket:** PH-11
**Date:** 2026-02-17
**PRD:** `docs/prd/PH-11.prd.md`
**Phase spec:** `docs/phase/phase-11.md`

---

## 1. Resolved Questions

The PRD has no open questions. The user confirmed: proceed with documented requirements only; no additional constraints or preferences.

---

## 2. Related Modules and Services

### 2.1 `src/parse.rs` — Primary change target

This file contains three of the four change categories: the `stdp::U32` parser, the `LogLine` struct, the `Parsable` impl for `LogLine`, and the `test_u32` test.

| Location | Lines | What |
|---|---|---|
| `stdp::U32` parser impl | 20-45 | `type Dest = u32` at line 22. Hint comment block at lines 37-39. Runtime zero check at lines 40-42. Return value at line 43. |
| `LogLine` struct | 1378-1381 | Field `pub request_id: u32` at line 1380. |
| `Parsable` impl for `LogLine` | 1382-1399 | Associated type uses `fn((LogKind, u32)) -> Self` at line 1388. Closure at line 1396 constructs `LogLine { kind, request_id }`. |
| `test_u32` test | 1424-1432 | Six assertions with expected `u32` values: `411`, `411`, `0x3`, `0x3ab`. Three error cases: `""`, `"-3"`, `"0x"`. |

### 2.2 `src/lib.rs` — Secondary change target

| Location | Lines | What |
|---|---|---|
| `read_log()` function signature | 63 | Parameter `request_ids: Vec<u32>` |
| Filtering logic | 69 | `request_ids.contains(&log.request_id)` -- no change needed in logic, only the types change |
| `test_errors_mode` test | 182-201 | `vec![1]` at line 184, `vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` at line 189 |
| `test_exchanges_mode` test | 204-233 | `vec![1]` at line 208, `vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` at line 213 |
| `test_all` test | 164-179 | `vec![]` at lines 166 and 171 -- these are empty vectors, so type inference will adapt automatically |

### 2.3 `src/main.rs` — No changes needed

Line 68 calls `read_log(file, analysis::ReadMode::All, vec![])`. The empty `vec![]` will have its type inferred from the updated `read_log()` signature (`Vec<NonZeroU32>`). No modification required.

---

## 3. Current Endpoints and Contracts

### 3.1 Public types affected

**`LogLine`** is a `pub` struct with `pub` fields, exported from `parse.rs` and re-exported from `lib.rs` via `pub mod parse; use parse::*;`. Changing `request_id: u32` to `request_id: NonZeroU32` is a breaking API change for any external code that:
- Constructs `LogLine` values with a `u32` for `request_id`
- Reads `request_id` expecting `u32`

**`read_log()`** is a `pub` function in `lib.rs`. Changing the `request_ids` parameter from `Vec<u32>` to `Vec<NonZeroU32>` is a breaking API change for any caller passing `Vec<u32>`.

**`stdp::U32`** is `pub` within the `stdp` module. Its `type Dest` changing from `u32` to `NonZeroU32` affects any code that calls `stdp::U32.parse()` and expects a `u32` result.

These are all acceptable per PRD constraint 5: "This is acceptable for this internal refactoring project."

### 3.2 Internal consumers

A search for `request_id` across `src/` confirms exactly five usage sites:
1. `src/parse.rs:1380` -- struct field definition
2. `src/parse.rs:1396` -- parser closure constructing `LogLine`
3. `src/lib.rs:63` -- `read_log()` parameter
4. `src/lib.rs:69` -- filtering comparison
5. `src/parse.rs:1376` -- doc comment (no change needed)

A search for `stdp::U32` across `src/` confirms usage in:
1. `src/parse.rs:1386` -- `Parsable` impl for `LogLine` (type parameter)
2. `src/parse.rs:1394` -- `Parsable` impl for `LogLine` (parser constructor)
3. `src/parse.rs:1425-1431` -- `test_u32` test assertions

---

## 4. Patterns Used

### 4.1 Parser combinator associated type pattern

Every `Parsable` impl spells out its `type Parser` using fully-qualified combinator types. The map function argument is typed as a **function pointer** (`fn(InputType) -> OutputType`), not as a generic closure type. For `LogLine`:

```rust
// Line 1388 (current)
fn((LogKind, u32)) -> Self
```

This must change to:

```rust
fn((LogKind, NonZeroU32)) -> Self
```

The closure at line 1396 (`|(kind, request_id)| LogLine { kind, request_id }`) is a non-capturing closure. After the change, the `request_id` parameter will be `NonZeroU32` instead of `u32`, and the `LogLine` struct field will also be `NonZeroU32`, so the closure remains a simple field-forwarding construction. It coerces to the function pointer type without issues.

### 4.2 `stdp` module import pattern

The `stdp` module at line 14 currently imports only `use super::Parser;`. The `NonZeroU32` type is needed inside this module. It must import `std::num::NonZeroU32` (either via `use std::num::NonZeroU32;` inside the module, or via a fully-qualified path in the code).

### 4.3 Hint comment removal pattern

Previous phases (PH-10, etc.) have removed `// подсказка:` comments after resolving the technical debt they identify. This is consistent with the project convention: "Focus on locations marked with `// подсказка:`. Fixing every hint is mandatory."

Currently two hint comments remain in `parse.rs`:
- Line 37-39: The three-line `NonZeroU32` hint (IN SCOPE for this ticket)
- Line 1412: The singleton hint (NOT in scope for this ticket)

Only the hint at lines 37-39 is removed by this phase.

---

## 5. Limitations and Risks

### 5.1 Test verbosity (LOW RISK)

Constructing `NonZeroU32` values in tests requires `NonZeroU32::new(n).unwrap()` instead of bare integer literals. This affects:
- `test_u32` in `parse.rs`: 4 assertions need `NonZeroU32` expected values
- `test_errors_mode` in `lib.rs`: 2 `vec![]` calls need `NonZeroU32` values
- `test_exchanges_mode` in `lib.rs`: 2 `vec![]` calls need `NonZeroU32` values

**Mitigation:** The PRD suggests using `(1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect()` for the `all_ids` vectors, and simple `vec![NonZeroU32::new(1).unwrap()]` for single-value vectors. A helper function `fn nz(n: u32) -> NonZeroU32` can be defined in the test module if verbosity becomes excessive.

### 5.2 Missing zero-value test (OBSERVATION)

The current `test_u32` does not include an assertion for `stdp::U32.parse("0")`. The runtime `if value == 0` check at line 40 rejects zero, and after the change, `NonZeroU32::new(0)` returns `None` which converts to `Err(())`. The behavior is preserved, but there is no explicit test covering this case. Consider adding `assert_eq!(stdp::U32.parse("0"), Err(()));` to the test.

**Note:** The PRD says "No test deletions" and "no test cases deleted." Adding a new assertion to an existing test is compatible with this constraint.

### 5.3 `NonZeroU32` Debug output (NO RISK)

`NonZeroU32`'s `Debug` impl prints the inner `u32` value directly. For example, `format!("{:?}", NonZeroU32::new(1).unwrap())` produces `"1"`, not `"NonZeroU32(1)"`. This means `cargo run -- example.log` output (which uses `{:?}` formatting for `LogLine`) will be identical for `request_id`.

Verified by checking the Rust standard library: `NonZeroU32` derives its `Debug` impl to print just the numeric value.

### 5.4 `contains()` comparison (NO RISK)

`NonZeroU32` implements `PartialEq`, so `Vec<NonZeroU32>::contains(&log.request_id)` works identically to the current `Vec<u32>::contains(&log.request_id)`. No logic change needed at line 69 of `lib.rs`.

### 5.5 `I32` parser out of scope (CONFIRMED)

The `stdp::I32` parser at lines 48-63 of `parse.rs` also has a `if value == 0 { return Err(()); }` check at line 58, but per PRD constraint 4: "The `stdp::I32` parser is not changed (it remains `i32`), as `request_id` is the only field affected." This parser is NOT modified in this phase.

---

## 6. Exact Changes Required

### Change 1: Add `NonZeroU32` import inside `stdp` module

**File:** `src/parse.rs`, inside `mod stdp` (after line 16)
**Add:**
```rust
use std::num::NonZeroU32;
```

### Change 2: Change `stdp::U32` Dest type and implementation

**File:** `src/parse.rs`, lines 22, 37-43
**Before:**
```rust
        type Dest = u32;
        fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, Self::Dest), ()> {
            // ... parsing logic unchanged ...
            let value = u32::from_str_radix(&remaining[..end_idx], if is_hex { 16 } else { 10 })
                .map_err(|_| ())?;
            // подсказка: вместо if можно использовать tight-тип std::num::NonZeroU32
            //            (ограничиться NonZeroU32::new(value).ok_or(()).get() - норм)
            //            или даже заиспользовать tightness
            if value == 0 {
                return Err(()); // в наших логах нет нулей, ноль в операции - фикция
            }
            Ok((&remaining[end_idx..], value))
```
**After:**
```rust
        type Dest = NonZeroU32;
        fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, Self::Dest), ()> {
            // ... parsing logic unchanged ...
            let value = u32::from_str_radix(&remaining[..end_idx], if is_hex { 16 } else { 10 })
                .map_err(|_| ())?;
            let non_zero = NonZeroU32::new(value).ok_or(())?;
            Ok((&remaining[end_idx..], non_zero))
```

This removes the three-line hint comment block (lines 37-39), the `if value == 0` check (lines 40-42), and replaces the return value `value` with `non_zero`.

### Change 3: Change `LogLine::request_id` type

**File:** `src/parse.rs`, line 1380
**Before:**
```rust
    pub request_id: u32,
```
**After:**
```rust
    pub request_id: std::num::NonZeroU32,
```

### Change 4: Update `Parsable` impl for `LogLine`

**File:** `src/parse.rs`, line 1388
**Before:**
```rust
        fn((LogKind, u32)) -> Self,
```
**After:**
```rust
        fn((LogKind, std::num::NonZeroU32)) -> Self,
```

The closure at line 1396 (`|(kind, request_id)| LogLine { kind, request_id }`) does NOT need to change -- it simply forwards the now-`NonZeroU32` value into the struct field.

### Change 5: Update `test_u32` assertions

**File:** `src/parse.rs`, lines 1425-1431
**Before:**
```rust
        assert_eq!(stdp::U32.parse("411"), Ok(("", 411)));
        assert_eq!(stdp::U32.parse("411ab"), Ok(("ab", 411)));
        assert_eq!(stdp::U32.parse(""), Err(()));
        assert_eq!(stdp::U32.parse("-3"), Err(()));
        assert_eq!(stdp::U32.parse("0x03"), Ok(("", 0x3)));
        assert_eq!(stdp::U32.parse("0x03abg"), Ok(("g", 0x3ab)));
        assert_eq!(stdp::U32.parse("0x"), Err(()));
```
**After:**
```rust
        use std::num::NonZeroU32;
        assert_eq!(stdp::U32.parse("411"), Ok(("", NonZeroU32::new(411).unwrap())));
        assert_eq!(stdp::U32.parse("411ab"), Ok(("ab", NonZeroU32::new(411).unwrap())));
        assert_eq!(stdp::U32.parse(""), Err(()));
        assert_eq!(stdp::U32.parse("-3"), Err(()));
        assert_eq!(stdp::U32.parse("0x03"), Ok(("", NonZeroU32::new(0x3).unwrap())));
        assert_eq!(stdp::U32.parse("0x03abg"), Ok(("g", NonZeroU32::new(0x3ab).unwrap())));
        assert_eq!(stdp::U32.parse("0x"), Err(()));
```

### Change 6: Update `read_log()` signature

**File:** `src/lib.rs`, line 63
**Before:**
```rust
    request_ids: Vec<u32>,
```
**After:**
```rust
    request_ids: Vec<std::num::NonZeroU32>,
```

Also add `use std::num::NonZeroU32;` to the imports at the top of `lib.rs` (or in the test module).

### Change 7: Update `lib.rs` test call sites

**File:** `src/lib.rs`, tests

- Line 184: `vec![1]` becomes `vec![NonZeroU32::new(1).unwrap()]`
- Line 189: `vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` becomes `(1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect()`
- Line 208: `vec![1]` becomes `vec![NonZeroU32::new(1).unwrap()]`
- Line 213: `vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` becomes `(1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect()`
- Lines 166, 171: `vec![]` -- no change needed, type inference handles it

A `use std::num::NonZeroU32;` import is needed in the test module (either in `mod test` or at the crate level).

---

## 7. Import Strategy

The `NonZeroU32` type needs to be available in several locations:

| Location | Recommended import |
|---|---|
| `mod stdp` in `parse.rs` | `use std::num::NonZeroU32;` inside the module (line 16+) |
| `LogLine` struct and `Parsable` impl in `parse.rs` | Use fully-qualified `std::num::NonZeroU32` or add a top-level import above `mod stdp` |
| `test` module in `parse.rs` | `use std::num::NonZeroU32;` inside the test function |
| `read_log()` in `lib.rs` | `use std::num::NonZeroU32;` at the crate level (near line 3) |
| `test` module in `lib.rs` | Inherits crate-level import via `use super::*;` |

The simplest approach: add `use std::num::NonZeroU32;` at the top of `parse.rs` (before `mod stdp`), then it is available in the outer scope. Inside `mod stdp`, add a separate `use std::num::NonZeroU32;`. In `lib.rs`, add `use std::num::NonZeroU32;` at the crate level.

---

## 8. Verification

```bash
cargo test                    # All 25 tests must pass
cargo run -- example.log      # Output must be identical to pre-change
```

---

## 9. New Technical Questions

None discovered. The change is purely mechanical type substitution across a well-defined set of locations. All affected sites have been identified and verified.

---

## 10. Deviations from Requirements

**No deviations found.** The current codebase matches the PRD's description exactly:

- `stdp::U32` has `type Dest = u32` at line 22
- The hint comment block is at lines 37-39
- The runtime zero check is at lines 40-42
- `LogLine::request_id` is `u32` at line 1380
- The `Parsable` impl for `LogLine` uses `fn((LogKind, u32)) -> Self` at line 1388
- `read_log()` accepts `Vec<u32>` at line 63
- Test call sites use bare integer literals
- The `I32` parser is confirmed out of scope
- No external dependencies exist in `Cargo.toml`
