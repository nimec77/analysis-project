# Research: PH-12 — Remove `OnceLock` singleton

**Ticket:** PH-12
**Date:** 2026-02-17
**PRD:** `docs/prd/PH-12.prd.md`
**Phase spec:** `docs/phase/phase-12.md`

---

## 1. Resolved Questions

The PRD has no open questions. The user confirmed: proceed with documented requirements only; no additional constraints or preferences.

---

## 2. Related Modules and Services

### 2.1 `src/parse.rs` — Primary deletion target

This file contains the `LogLineParser` struct, its `impl` block, the hint comments, the doc comment, and the `pub static LOG_LINE_PARSER` declaration. All of these are deleted; no replacement code is added in this file.

| Location | Lines | What |
|---|---|---|
| `LogLineParser` struct | 1397-1399 | `pub struct LogLineParser` with a single field `parser: std::sync::OnceLock<<LogLine as Parsable>::Parser>` |
| `impl LogLineParser` | 1401-1406 | Single method `pub fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, LogLine), ()>` that calls `self.parser.get_or_init(\|\| <LogLine as Parsable>::parser()).parse(input)` |
| Hint comments | 1408-1409 | `// подсказка: singleton, без которого можно обойтись` and `// парсеры не страшно вытащить в pub` |
| Doc comment | 1410 | `/// Единожды собранный парсер логов` |
| `pub static LOG_LINE_PARSER` | 1411-1413 | `pub static LOG_LINE_PARSER: LogLineParser = LogLineParser { parser: std::sync::OnceLock::new(), };` |

### 2.2 `src/lib.rs` — Primary modification target

This file contains the `LogIterator<R>` struct and its `Iterator` impl, where the singleton is consumed. The struct gains a new `parser` field; the `Iterator::next()` method switches from `LOG_LINE_PARSER.parse(...)` to `self.parser.parse(...)`.

| Location | Lines | What |
|---|---|---|
| `LogIterator<R>` struct | 18-24 | Currently has one field: `lines`. Gains a second field: `parser: <LogLine as Parsable>::Parser`. |
| `LogIterator::new()` | 26-39 | Constructor. Must initialize the new `parser` field with `LogLine::parser()`. |
| `LogIterator::next()` | 43-57 | Line 50: `LOG_LINE_PARSER.parse(line.trim())`. Becomes `self.parser.parse(line.trim())`. |
| `use parse::*;` import | 2 | Glob import. Currently imports `LOG_LINE_PARSER`. After deletion, the import remains unchanged but no longer imports the removed symbol. `Parsable`, `Parser`, and `LogLine` are still imported via this glob. |

### 2.3 `src/main.rs` — No changes needed

`main.rs` does not reference `LOG_LINE_PARSER` or `LogLineParser`. It calls `analysis::read_log()` which internally creates a `LogIterator`. No modification required.

### 2.4 Tests — No changes needed

A search for `LOG_LINE_PARSER` and `LogLineParser` across `src/` confirms:
- **`src/parse.rs` tests (lines 1415-1610):** Zero references to `LOG_LINE_PARSER` or `LogLineParser`. Tests use `stdp::U32.parse(...)`, combinator-level parsers, and `just_parse::<T>(...)`. None touches the singleton.
- **`src/lib.rs` tests (lines 94-243):** Zero references to `LOG_LINE_PARSER` or `LogLineParser`. Tests call `read_log()` which internally creates `LogIterator`. The change to `LogIterator`'s internals is invisible to tests.

No test modifications are needed.

---

## 3. Current Endpoints and Contracts

### 3.1 Public types affected

**`LogLineParser`** is a `pub` struct exported from `parse.rs` and re-exported from `lib.rs` via `pub mod parse; use parse::*;`. Deleting it is a breaking change for any external code that:
- References the `LogLineParser` type
- Calls `LOG_LINE_PARSER.parse(...)`

**`LOG_LINE_PARSER`** is a `pub static` exported from `parse.rs`. Deleting it is a breaking change for any external code that accesses this static.

These are acceptable per PRD constraint 6: "This is acceptable for this internal refactoring project. External consumers should use `<LogLine as Parsable>::parser()` directly."

### 3.2 Public types NOT affected

The following public items remain unchanged:
- `pub trait Parser` -- still public, still has `fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, Self::Dest), ()>`
- `pub trait Parsable` -- still public, still has `fn parser() -> Self::Parser`
- `pub struct LogLine` -- unchanged
- `impl Parsable for LogLine` -- unchanged, still provides `LogLine::parser()`
- `pub fn read_log(...)` -- unchanged signature and behavior
- `pub fn just_parse::<T>(...)` -- unchanged
- All data model types (`LogKind`, `SystemLogKind`, `AppLogKind`, etc.) -- unchanged

### 3.3 Internal consumers of `LOG_LINE_PARSER`

A comprehensive search confirms exactly **two** references in source code:
1. `src/parse.rs:1411` -- definition site (`pub static LOG_LINE_PARSER`)
2. `src/lib.rs:50` -- usage site (`LOG_LINE_PARSER.parse(line.trim())`)

No other code references `LOG_LINE_PARSER` or `LogLineParser`.

---

## 4. Patterns Used

### 4.1 `Parsable` trait pattern for local parser construction

Every data model type in `parse.rs` implements the `Parsable` trait, which returns a concrete parser via `fn parser() -> Self::Parser`. The `LogLine` implementation (lines 1378-1395) is:

```rust
impl Parsable for LogLine {
    type Parser = Map<
        All<(
            <LogKind as Parsable>::Parser,
            StripWhitespace<Preceded<Tag, stdp::U32>>,
        )>,
        fn((LogKind, std::num::NonZeroU32)) -> Self,
    >;
    fn parser() -> Self::Parser {
        map(
            all2(
                LogKind::parser(),
                strip_whitespace(preceded(tag("requestid="), stdp::U32)),
            ),
            |(kind, request_id)| LogLine { kind, request_id },
        )
    }
}
```

The associated type `<LogLine as Parsable>::Parser` is a fully concrete type: `Map<All<(...)>, fn(...) -> LogLine>`. It is composed entirely of concrete combinator structs (`Map`, `All`, `StripWhitespace`, `Preceded`, `Tag`, `stdp::U32`), none of which contain heap allocations or dynamic dispatch. The type is directly usable as a struct field.

### 4.2 Parser combinator struct pattern

All combinator types (`Tag`, `Map`, `All`, `StripWhitespace`, `Preceded`, etc.) are declared as `pub struct` with `#[derive(Debug, Clone)]`. They store only:
- `&'static str` references (e.g., `Tag { tag: &'static str }`)
- Other combinator structs (e.g., `StripWhitespace<T> { parser: T }`)
- Function pointers (e.g., `Map<T, M> { parser: T, map: M }`)
- Zero-sized type markers

Construction via `LogLine::parser()` is a purely stack-based operation with no heap allocations. This was confirmed as part of Phase 1 (`String` -> `&str` migration).

### 4.3 `LogIterator` struct pattern

`LogIterator<R>` currently has a single field `lines` with a complex type annotation (using `#[allow(clippy::type_complexity)]`). Adding a second field follows the same pattern. The `new()` constructor initializes all fields using `Self { ... }` struct literal syntax.

### 4.4 Hint comment removal pattern

Previous phases (PH-10, PH-11) have removed `// подсказка:` comments after resolving the technical debt they identify. This is the **last remaining hint** in the codebase:
- Line 1408: `// подсказка: singleton, без которого можно обойтись` ("hint: a singleton you can do without")
- Line 1409: `// парсеры не страшно вытащить в pub` ("parsers are safe to make pub")

After this phase, zero `подсказка` hints remain in the codebase.

---

## 5. Limitations and Risks

### 5.1 Deeply nested parser type (LOW RISK)

The `<LogLine as Parsable>::Parser` type expands to a deeply nested combinator tree: `Map<All<(<LogKind as Parsable>::Parser, StripWhitespace<Preceded<Tag, stdp::U32>>)>, fn((LogKind, NonZeroU32)) -> LogLine>`, where `<LogKind as Parsable>::Parser` itself expands further through `SystemLogKind`, `AppLogKind`, and their variants. The full expansion is many levels deep.

**Mitigation:** The associated type syntax `<LogLine as Parsable>::Parser` is used directly as the field type, so the deeply nested expansion is handled by the compiler. The programmer never needs to spell out the full type. This is the same approach already used in every `Parsable` impl's `type Parser = ...` declaration throughout `parse.rs`.

### 5.2 Parser construction cost per iterator (NO RISK)

Constructing the parser per `LogIterator` instance (once per `read_log()` call) instead of once globally via `OnceLock` could theoretically have a performance impact if construction were expensive. After Phase 1, all combinators are lightweight stack-only structs. Construction is purely register/stack initialization with no heap allocation. The cost is negligible.

**Verified:** The `just_parse::<T>()` function (introduced in PH-8) already constructs a parser per call via `T::parser().parse(input)` and is used without performance concerns.

### 5.3 No tests reference `LOG_LINE_PARSER` (CONFIRMED NO RISK)

A grep of `src/` confirms that `LOG_LINE_PARSER` appears only at its definition (line 1411) and its single usage (line 50 of `lib.rs`). No test function references it. Deleting it will not break any test.

### 5.4 Glob import `use parse::*` (CONFIRMED NO RISK)

The `use parse::*;` glob import at line 2 of `lib.rs` currently imports `LOG_LINE_PARSER` and `LogLineParser` among many other items. After deletion, the glob import still brings in `LogLine`, `LogKind`, `Parsable`, `Parser`, and all data model types used extensively in `lib.rs`. Removing two items from the export set has no effect on the import statement.

### 5.5 `OnceLock` usage elsewhere (CONFIRMED NONE)

A search for `OnceLock` across `src/` confirms it appears only in the `LogLineParser` struct (line 1399) and the `LOG_LINE_PARSER` static (line 1412). No other code uses `std::sync::OnceLock`. After deletion, zero `OnceLock` references remain.

---

## 6. Exact Changes Required

### Change 1: Delete `LogLineParser` struct, impl, comments, and static from `parse.rs`

**File:** `src/parse.rs`, lines 1397-1413
**Action:** Delete the following 17 lines entirely:

```rust
/// Парсер строки логов
pub struct LogLineParser {
    parser: std::sync::OnceLock<<LogLine as Parsable>::Parser>,
}
impl LogLineParser {
    pub fn parse<'a>(&self, input: &'a str) -> Result<(&'a str, LogLine), ()> {
        self.parser
            .get_or_init(|| <LogLine as Parsable>::parser())
            .parse(input)
    }
}
// подсказка: singleton, без которого можно обойтись
// парсеры не страшно вытащить в pub
/// Единожды собранный парсер логов
pub static LOG_LINE_PARSER: LogLineParser = LogLineParser {
    parser: std::sync::OnceLock::new(),
};
```

No replacement code is added in `parse.rs`. The blank line at line 1396 (between the `Parsable` impl and the deleted block) should be preserved as a separator before `#[cfg(test)]`.

### Change 2: Add `parser` field to `LogIterator<R>` struct

**File:** `src/lib.rs`, lines 18-24
**Before:**
```rust
struct LogIterator<R: Read> {
    #[allow(clippy::type_complexity)]
    lines: std::iter::Filter<
        std::io::Lines<std::io::BufReader<R>>,
        fn(&Result<String, std::io::Error>) -> bool,
    >,
}
```
**After:**
```rust
struct LogIterator<R: Read> {
    #[allow(clippy::type_complexity)]
    lines: std::iter::Filter<
        std::io::Lines<std::io::BufReader<R>>,
        fn(&Result<String, std::io::Error>) -> bool,
    >,
    parser: <LogLine as Parsable>::Parser,
}
```

### Change 3: Initialize `parser` field in `LogIterator::new()`

**File:** `src/lib.rs`, lines 26-39
**Before:**
```rust
impl<R: Read> LogIterator<R> {
    fn new(reader: R) -> Self {
        use std::io::BufRead;
        Self {
            lines: std::io::BufReader::with_capacity(4096, reader)
                .lines()
                .filter(|line_res| {
                    !line_res
                        .as_ref()
                        .ok()
                        .map(|line| line.trim().is_empty())
                        .unwrap_or(false)
                }),
        }
    }
}
```
**After:**
```rust
impl<R: Read> LogIterator<R> {
    fn new(reader: R) -> Self {
        use std::io::BufRead;
        Self {
            lines: std::io::BufReader::with_capacity(4096, reader)
                .lines()
                .filter(|line_res| {
                    !line_res
                        .as_ref()
                        .ok()
                        .map(|line| line.trim().is_empty())
                        .unwrap_or(false)
                }),
            parser: LogLine::parser(),
        }
    }
}
```

### Change 4: Replace `LOG_LINE_PARSER.parse(...)` with `self.parser.parse(...)` in `next()`

**File:** `src/lib.rs`, line 50
**Before:**
```rust
            let Ok((remaining, result)) = LOG_LINE_PARSER.parse(line.trim()) else {
```
**After:**
```rust
            let Ok((remaining, result)) = self.parser.parse(line.trim()) else {
```

---

## 7. Import Strategy

No new imports are needed.

- `src/lib.rs` already has `use parse::*;` which imports `LogLine`, `Parsable`, and `Parser` -- all needed for `LogLine::parser()` and `<LogLine as Parsable>::Parser`.
- `src/parse.rs` has no new imports needed; code is only deleted.
- `src/main.rs` has no changes.

The `use parse::*;` glob import at line 2 of `lib.rs` remains unchanged. It will no longer import `LOG_LINE_PARSER` or `LogLineParser` because those symbols are deleted. The `Parsable` trait and `LogLine` struct (both `pub`) continue to be imported and are used by the new `LogLine::parser()` call in `LogIterator::new()`.

---

## 8. Verification

```bash
cargo test                    # All 25 tests must pass
cargo run -- example.log      # Output must be identical to pre-change
```

Additional verification:
- Zero occurrences of `OnceLock` in `src/parse.rs`
- Zero occurrences of `LogLineParser` in `src/parse.rs`
- Zero occurrences of `LOG_LINE_PARSER` in `src/lib.rs`
- Zero occurrences of `LOG_LINE_PARSER` in `src/parse.rs`
- Zero occurrences of `подсказка: singleton, без которого можно обойтись` in `src/parse.rs`
- Zero occurrences of `парсеры не страшно вытащить в pub` in `src/parse.rs`
- `parser: <LogLine as Parsable>::Parser` is present as a field in `LogIterator`
- `parser: LogLine::parser()` is present in `LogIterator::new()`
- `self.parser.parse(line.trim())` is present in `LogIterator::next()`
- No external dependencies added to `Cargo.toml`
- No files other than `src/parse.rs` and `src/lib.rs` are modified

---

## 9. New Technical Questions

None discovered. The change is purely structural deletion in `parse.rs` and a mechanical field-addition in `lib.rs`. All affected sites have been identified and verified. The parser type is confirmed to be concrete and usable as a struct field. No test modifications are needed.

---

## 10. Deviations from Requirements

**No deviations found.** The current codebase matches the PRD's description exactly:

- `LogLineParser` struct is at lines 1397-1399 of `src/parse.rs` (PRD says "lines 1397-1406" for struct+impl; confirmed struct at 1397-1399, impl at 1401-1406)
- `impl LogLineParser` with `parse()` method is at lines 1401-1406
- Hint comments are at lines 1408-1409
- Doc comment is at line 1410
- `pub static LOG_LINE_PARSER` is at lines 1411-1413
- `LOG_LINE_PARSER.parse(line.trim())` is at line 50 of `src/lib.rs`
- `LogIterator<R>` struct has one field (`lines`) at lines 18-24 of `src/lib.rs`
- `LogIterator::new()` constructor is at lines 26-39
- `LogIterator::next()` is at lines 43-57
- `use parse::*;` glob import is at line 2
- No tests reference `LOG_LINE_PARSER` or `LogLineParser`
- Phase 1 (prerequisite) is already complete -- `Parser` trait operates on `&str`, combinators store only `&'static str` and ZSTs
- `Parsable` and `Parser` traits are already `pub` (done in PH-8)
- Zero external dependencies in `Cargo.toml`
- All 25 tests pass in the current codebase
