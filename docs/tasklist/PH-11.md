# Tasklist: PH-11 -- `NonZeroU32` Tight Type

**Status:** IMPLEMENT_STEP_OK
**Ticket:** PH-11
**PRD:** `docs/prd/PH-11.prd.md`
**Plan:** `docs/plan/PH-11.md`

---

## Context

Phase 11 replaces the `u32` type used for `request_id` with `std::num::NonZeroU32` throughout the codebase, encoding the "request IDs are never zero" invariant directly in the type system. The `stdp::U32` parser currently uses a runtime `if value == 0 { return Err(()); }` check to reject zero values. This is replaced by `NonZeroU32::new(value).ok_or(())?`, which encodes the same guarantee at the type level. The change propagates through `LogLine::request_id`, the `Parsable` impl for `LogLine`, the `read_log()` function signature, and all test call sites. The hint comment block identifying this technical debt is removed.

No deviations identified in the plan -- the codebase matches the PRD's "before" state exactly.

---

## Tasks

- [x] **11.1 Add `NonZeroU32` import and update `stdp::U32` parser**

  In `src/parse.rs`, inside the `mod stdp` block (lines 14-45):
  1. Add `use std::num::NonZeroU32;` after the existing `use super::Parser;` import.
  2. Change `type Dest = u32;` to `type Dest = NonZeroU32;`.
  3. Remove the three-line hint comment block:
     ```
     // подсказка: вместо if можно использовать tight-тип std::num::NonZeroU32
     //            (ограничиться NonZeroU32::new(value).ok_or(()).get() - норм)
     //            или даже заиспользовать tightness
     ```
  4. Remove the runtime zero check:
     ```rust
     if value == 0 {
         return Err(()); // в наших логах нет нулей, ноль в операции - фикция
     }
     ```
  5. Replace the removed lines with: `let non_zero = NonZeroU32::new(value).ok_or(())?;`
  6. Change the return value from `value` to `non_zero`: `Ok((&remaining[end_idx..], non_zero))`

  **Acceptance criteria:**
  1. `type Dest = NonZeroU32;` is present in the `stdp::U32` parser impl.
  2. `NonZeroU32::new(value).ok_or(())?` is present in the parser, replacing the `if value == 0` check.
  3. Zero occurrences of `подсказка: вместо if можно использовать tight-тип` in `src/parse.rs`.
  4. Zero occurrences of `if value == 0` in `src/parse.rs` (within the `stdp::U32` parser).
  5. `use std::num::NonZeroU32;` import exists inside `mod stdp`.

- [x] **11.2 Update `LogLine` struct and `Parsable` impl**

  In `src/parse.rs`:
  1. Change the `LogLine` struct field `pub request_id: u32` to `pub request_id: std::num::NonZeroU32`.
  2. In the `Parsable` impl for `LogLine`, change the function pointer type from `fn((LogKind, u32)) -> Self` to `fn((LogKind, std::num::NonZeroU32)) -> Self`.
  3. The parser closure `|(kind, request_id)| LogLine { kind, request_id }` requires no change.

  **Acceptance criteria:**
  1. `LogLine::request_id` has type `std::num::NonZeroU32`.
  2. The `Parsable` impl for `LogLine` uses `fn((LogKind, std::num::NonZeroU32)) -> Self` in the associated `Parser` type.

- [x] **11.3 Update `read_log()` signature in `lib.rs`**

  In `src/lib.rs`:
  1. Add `use std::num::NonZeroU32;` at the crate level (near the existing imports).
  2. Change the `read_log()` parameter from `request_ids: Vec<u32>` to `request_ids: Vec<NonZeroU32>`.

  **Acceptance criteria:**
  1. `use std::num::NonZeroU32;` import exists at the crate level in `src/lib.rs`.
  2. `read_log()` accepts `request_ids: Vec<NonZeroU32>`.
  3. The filtering logic `request_ids.contains(&log.request_id)` compiles without changes (since `NonZeroU32` implements `PartialEq`).

- [x] **11.4 Update test call sites**

  Update all test assertions and call sites to use `NonZeroU32` values:

  In `src/parse.rs` -- `test_u32`:
  - Add `use std::num::NonZeroU32;` inside the test function.
  - Update four `Ok(...)` assertions to wrap expected values in `NonZeroU32::new(...).unwrap()`.
  - Error assertions (`""`, `"-3"`, `"0x"`) remain unchanged.

  In `src/lib.rs` -- `test_errors_mode`:
  - Change `vec![1]` to `vec![NonZeroU32::new(1).unwrap()]`.
  - Change `vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` to `(1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect()`.

  In `src/lib.rs` -- `test_exchanges_mode`:
  - Change `vec![1]` to `vec![NonZeroU32::new(1).unwrap()]`.
  - Change `vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` to `(1..=10).map(|n| NonZeroU32::new(n).unwrap()).collect()`.

  In `src/lib.rs` -- `test_all`:
  - No changes needed. Empty `vec![]` type-infers correctly.

  In `src/main.rs`:
  - No changes needed. Empty `vec![]` type-infers correctly.

  **Acceptance criteria:**
  1. `test_u32` assertions use `NonZeroU32::new(...).unwrap()` for expected `Ok(...)` values.
  2. `test_errors_mode` constructs `NonZeroU32` values for the `request_ids` parameter.
  3. `test_exchanges_mode` constructs `NonZeroU32` values for the `request_ids` parameter.
  4. `test_all` and `main.rs` are unchanged.
  5. No test cases are deleted.

- [x] **11.5 Verify**

  Run acceptance checks to confirm the refactoring is complete and correct.

  **Acceptance criteria:**
  1. `cargo test` passes all tests. No test cases deleted.
  2. `cargo run -- example.log` succeeds and output is identical to pre-refactoring.
  3. `type Dest = NonZeroU32;` is present in `stdp::U32`.
  4. `NonZeroU32::new(value).ok_or(())?` is present in `stdp::U32`.
  5. `pub request_id: std::num::NonZeroU32` is present in `LogLine`.
  6. `fn((LogKind, std::num::NonZeroU32)) -> Self` is present in the `Parsable` impl for `LogLine`.
  7. `request_ids: Vec<NonZeroU32>` is present in the `read_log()` signature.
  8. Zero occurrences of `подсказка: вместо if можно использовать tight-тип` in `src/parse.rs`.
  9. Zero occurrences of the runtime `if value == 0` check in the `stdp::U32` parser.
  10. `use std::num::NonZeroU32;` imports are present in both `mod stdp` and `src/lib.rs`.
  11. Test assertions use `NonZeroU32::new(...).unwrap()` for expected values.
  12. No changes in `src/main.rs`.
  13. `stdp::I32` parser is unchanged.
  14. Zero external dependencies added.
  15. Number of tests is the same as before (none deleted).
